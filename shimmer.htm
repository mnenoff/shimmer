<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shimmer</title>
    <style>
        body,html{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#111;cursor:pointer;font-family:'Segoe UI',Roboto,Helvetica,Arial,sans-serif}
        canvas{display:block}
        .controls{position:absolute;bottom:15px;left:15px;z-index:100;display:flex;flex-direction:column;gap:4px;width:180px;padding:12px;background:rgba(0,0,0,0.1);border-radius:8px;backdrop-filter:blur(2px);opacity:0.15;transition:all 0.4s ease;color:rgba(255,255,255,0.8);pointer-events:all}
        .controls:hover{opacity:1;background:rgba(0,0,0,0.65);backdrop-filter:blur(8px);box-shadow:0 4px 15px rgba(0,0,0,0.4)}
        .control-row{display:flex;flex-direction:column;margin-bottom:6px}
        .label-line{display:flex;justify-content:space-between;align-items:baseline;font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:1px;margin-bottom:3px;color:rgba(255,255,255,0.6)}
        .val-display{font-family:monospace;color:#fff;font-size:11px}
        input[type=range]{width:100%;cursor:pointer;-webkit-appearance:none;background:rgba(255,255,255,0.15);border-radius:2px;height:3px}
        input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;background:#ccc;border-radius:50%;border:1px solid rgba(0,0,0,0.5);transition:background .2s,transform .2s}
        input[type=range]::-webkit-slider-thumb:hover{background:#fff;transform:scale(1.2)}
        input[type=range]::-moz-range-thumb{width:12px;height:12px;background:#ccc;border:none;border-radius:50%}
        #dimOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;opacity:0.5;pointer-events:none;z-index:9999}
    </style>
</head>
<body>
    <div class="controls">
        <div class="control-row">
            <div class="label-line"><span>Mutation</span><span id="vMut" class="val-display">18%</span></div>
            <input type="range" id="mutationSlider" min="0" max="100" value="18">
        </div>
        <div class="control-row">
            <div class="label-line"><span>Brightness</span><span id="vDim" class="val-display">50%</span></div>
            <input type="range" id="dimSlider" min="0" max="99" value="50">
        </div>
        <div class="control-row">
            <div class="label-line"><span>Drift Rate</span><span id="vDrift" class="val-display">20%</span></div>
            <input type="range" id="driftSlider" min="0" max="100" value="20">
        </div>
        <div class="control-row">
            <div class="label-line"><span>Color Rate</span><span id="vColor" class="val-display">94</span></div>
            <input type="range" id="colorRateSlider" min="1" max="100" value="94">
        </div>
        <div class="control-row">
            <div class="label-line"><span>Distortion</span><span id="vDist" class="val-display">35%</span></div>
            <input type="range" id="distortSlider" min="0" max="100" value="35">
        </div>
    </div>
    <div id="dimOverlay"></div>
    <canvas id="canvas"></canvas>
    <script>
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        const palette = ['#000000','#FFFFFF','#00FF00','#FF00FF','#FFFF00','#0000FF','#FF0000','#00FFFF','#FF8000','#007FFF','#80FF00','#7F00FF','#008080','#FF7F7F'];
        const numColors = palette.length;
        const tileSize = 30;
        
        let w, ht, paused = false, lastColorTime = 0;
        
        const rateToInterval = v => 1020 - v * 10;
        
        let mutationRate = 0.18;
        let driftSpeed = 0.20;
        let colorUpdateInterval = rateToInterval(94);
        let jitterScale = 0.35 * 0.9;
        
        let gridA, gridB, activeGrid, nextGrid, neighborLUT;
        let totalCells = 0, gridW = 0, gridH = 0, radius = 0;
        let nodePositions, nodeTargets, nodeCount = 0;
        
        const bufs = Array.from({length: numColors}, () => new Float32Array(1200000));
        const counts = new Uint32Array(numColors);
        const de2000 = new Float32Array(numColors * numColors);

        (function buildColorMatrix() {
            const toLab = hex => {
                let v = parseInt(hex.slice(1), 16);
                let r = ((v >> 16) & 255) / 255, g = ((v >> 8) & 255) / 255, b = (v & 255) / 255;
                r = r > .04045 ? Math.pow((r + .055) / 1.055, 2.4) : r / 12.92;
                g = g > .04045 ? Math.pow((g + .055) / 1.055, 2.4) : g / 12.92;
                b = b > .04045 ? Math.pow((b + .055) / 1.055, 2.4) : b / 12.92;
                let x = (r * .4124564 + g * .3575761 + b * .1804375) / .95047;
                let y = r * .2126729 + g * .7151522 + b * .0721750;
                let z = (r * .0193339 + g * .1191920 + b * .9503041) / 1.08883;
                x = x > .008856 ? Math.pow(x, 1/3) : 7.787 * x + 16/116;
                y = y > .008856 ? Math.pow(y, 1/3) : 7.787 * y + 16/116;
                z = z > .008856 ? Math.pow(z, 1/3) : 7.787 * z + 16/116;
                return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
            };
            const deltaE = (a, b) => {
                const C1 = Math.sqrt(a[1]*a[1]+a[2]*a[2]), C2 = Math.sqrt(b[1]*b[1]+b[2]*b[2]), Cb = (C1+C2)/2;
                const G = .5*(1-Math.sqrt(Math.pow(Cb,7)/(Math.pow(Cb,7)+6103515625)));
                const a1p = (1+G)*a[1], a2p = (1+G)*b[1];
                const C1p = Math.sqrt(a1p*a1p+a[2]*a[2]), C2p = Math.sqrt(a2p*a2p+b[2]*b[2]);
                let h1p = Math.atan2(a[2],a1p)*180/Math.PI; if(h1p<0)h1p+=360;
                let h2p = Math.atan2(b[2],a2p)*180/Math.PI; if(h2p<0)h2p+=360;
                let dhp = h2p-h1p; if(C1p*C2p!==0){if(dhp>180)dhp-=360;else if(dhp<-180)dhp+=360}else dhp=0;
                const dHp = 2*Math.sqrt(C1p*C2p)*Math.sin(dhp*Math.PI/360);
                const Lbp = (a[0]+b[0])/2, Cbp = (C1p+C2p)/2;
                let hbp = h1p+h2p; if(C1p*C2p!==0){hbp/=2;if(Math.abs(h1p-h2p)>180)hbp+=hbp<180?180:-180}
                const T = 1-.17*Math.cos((hbp-30)*Math.PI/180)+.24*Math.cos(2*hbp*Math.PI/180)+.32*Math.cos((3*hbp+6)*Math.PI/180)-.2*Math.cos((4*hbp-63)*Math.PI/180);
                const Sl = 1+.015*Math.pow(Lbp-50,2)/Math.sqrt(20+Math.pow(Lbp-50,2)), Sc = 1+.045*Cbp, Sh = 1+.015*Cbp*T;
                const Rt = -Math.sin(2*30*Math.exp(-Math.pow((hbp-275)/25,2))*Math.PI/180)*2*Math.sqrt(Math.pow(Cbp,7)/(Math.pow(Cbp,7)+6103515625));
                return Math.sqrt(Math.pow((b[0]-a[0])/Sl,2)+Math.pow((C2p-C1p)/Sc,2)+Math.pow(dHp/Sh,2)+Rt*((C2p-C1p)/Sc)*(dHp/Sh));
            };
            const labs = palette.map(toLab);
            for(let i = 0; i < numColors; i++)
                for(let j = 0; j < numColors; j++)
                    de2000[i * numColors + j] = deltaE(labs[i], labs[j]);
        })();

        const updateVal = (id, val, suffix='') => document.getElementById(id).textContent = val + suffix;

        mutationSlider.oninput = function() { mutationRate = this.value / 100; updateVal('vMut', this.value, '%'); };
        dimSlider.oninput = function() { dimOverlay.style.opacity = this.value / 100; updateVal('vDim', this.value, '%'); };
        driftSlider.oninput = function() { driftSpeed = this.value / 100; updateVal('vDrift', this.value, '%'); };
        colorRateSlider.oninput = function() { colorUpdateInterval = rateToInterval(this.value); updateVal('vColor', this.value); };
        distortSlider.oninput = function() { jitterScale = (this.value / 100) * 0.9; updateVal('vDist', this.value, '%'); };

        function initGrid() {
            w = canvas.width = innerWidth;
            ht = canvas.height = innerHeight;
            radius = ((Math.sqrt(w * w + ht * ht) / tileSize) >> 1) + 2;
            gridW = gridH = radius << 1;
            totalCells = gridW * gridH * 8;
            
            gridA = new Uint8Array(totalCells);
            gridB = new Uint8Array(totalCells);
            activeGrid = gridA;
            nextGrid = gridB;
            neighborLUT = new Int32Array(totalCells * 3);
            
            const cornerCount = (gridW + 1) * (gridH + 1);
            const hMidCount = gridW * (gridH + 1);
            const vMidCount = (gridW + 1) * gridH;
            nodeCount = cornerCount + hMidCount + vMidCount + gridW * gridH;
            
            nodePositions = new Float32Array(nodeCount * 2);
            nodeTargets = new Float32Array(nodeCount * 2);
            
            const c45 = Math.SQRT1_2, cx = w >> 1, cy = ht >> 1;
            const currentJit = tileSize * jitterScale;

            const initNode = (idx, baseX, baseY, isCenter) => {
                const rx = baseX * c45 - baseY * c45 + cx;
                const ry = baseX * c45 + baseY * c45 + cy;
                const jit = isCenter ? 0 : currentJit;
                nodePositions[idx * 2] = rx + (Math.random() - 0.5) * jit;
                nodePositions[idx * 2 + 1] = ry + (Math.random() - 0.5) * jit;
                nodeTargets[idx * 2] = rx + (Math.random() - 0.5) * jit;
                nodeTargets[idx * 2 + 1] = ry + (Math.random() - 0.5) * jit;
            };
            
            let idx = 0;
            for (let ty = 0; ty <= gridH; ty++) for (let tx = 0; tx <= gridW; tx++, idx++)
                initNode(idx, (tx - radius) * tileSize, (ty - radius) * tileSize, false);
            for (let ty = 0; ty <= gridH; ty++) for (let tx = 0; tx < gridW; tx++, idx++)
                initNode(idx, (tx - radius + 0.5) * tileSize, (ty - radius) * tileSize, false);
            for (let ty = 0; ty < gridH; ty++) for (let tx = 0; tx <= gridW; tx++, idx++)
                initNode(idx, (tx - radius) * tileSize, (ty - radius + 0.5) * tileSize, false);
            for (let ty = 0; ty < gridH; ty++) for (let tx = 0; tx < gridW; tx++, idx++)
                initNode(idx, (tx - radius + 0.5) * tileSize, (ty - radius + 0.5) * tileSize, true);
            
            this.cellNodes = new Int32Array(totalCells * 3);
            const getCorner = (tx, ty) => ty * (gridW + 1) + tx;
            const getHMid = (tx, ty) => cornerCount + ty * gridW + tx;
            const getVMid = (tx, ty) => cornerCount + hMidCount + ty * (gridW + 1) + tx;
            const getCenter = (tx, ty) => cornerCount + hMidCount + vMidCount + ty * gridW + tx;
            const getIdx = (tx, ty, tri) => (ty * gridW + tx) * 8 + tri;
            const dx = [0, -1, -1, -1, 0, 1, 1, 1], dy = [-1, -1, 0, 1, 1, 1, 0, -1];

            for (let ty = 0; ty < gridH; ty++) {
                for (let tx = 0; tx < gridW; tx++) {
                    const center = getCenter(tx, ty);
                    const sur = [getHMid(tx, ty), getCorner(tx + 1, ty), getVMid(tx + 1, ty), getCorner(tx + 1, ty + 1), getHMid(tx, ty + 1), getCorner(tx, ty + 1), getVMid(tx, ty), getCorner(tx, ty)];
                    for (let tri = 0; tri < 8; tri++) {
                        const cellIdx = getIdx(tx, ty, tri);
                        activeGrid[cellIdx] = (Math.random() * numColors) | 0;
                        const nBase = cellIdx * 3;
                        neighborLUT[nBase] = getIdx(tx, ty, (tri + 1) & 7);
                        neighborLUT[nBase + 1] = getIdx(tx, ty, (tri + 7) & 7);
                        const ntx = tx + dx[tri], nty = ty + dy[tri];
                        neighborLUT[nBase + 2] = (ntx >= 0 && ntx < gridW && nty >= 0 && nty < gridH) ? getIdx(ntx, nty, (tri + 4) & 7) : -1;
                        this.cellNodes[nBase] = center;
                        this.cellNodes[nBase + 1] = sur[(9 - tri) & 7];
                        this.cellNodes[nBase + 2] = sur[(8 - tri) & 7];
                    }
                }
            }
        }

        function driftNodes() {
            const ease = 0.005 + driftSpeed * 0.08;
            const retargetProb = 0.005 + driftSpeed * 0.05;
            const c45 = Math.SQRT1_2, cx = w >> 1, cy = ht >> 1;
            const b1 = (gridW + 1) * (gridH + 1);
            const b2 = b1 + gridW * (gridH + 1);
            const b3 = b2 + (gridW + 1) * gridH;
            const currentJitAmp = tileSize * jitterScale;

            for (let i = 0; i < nodeCount; i++) {
                const px = i * 2, py = px + 1;
                nodePositions[px] += (nodeTargets[px] - nodePositions[px]) * ease;
                nodePositions[py] += (nodeTargets[py] - nodePositions[py]) * ease;
                
                if (Math.random() < retargetProb) {
                    const isCenter = i >= b3;
                    const jit = isCenter ? 0 : currentJitAmp;
                    let baseX, baseY;
                    if (i < b1) {
                        baseX = ((i % (gridW + 1)) - radius) * tileSize;
                        baseY = (((i / (gridW + 1)) | 0) - radius) * tileSize;
                    } else if (i < b2) {
                        const li = i - b1;
                        baseX = ((li % gridW) - radius + 0.5) * tileSize;
                        baseY = (((li / gridW) | 0) - radius) * tileSize;
                    } else if (i < b3) {
                        const li = i - b2;
                        baseX = ((li % (gridW + 1)) - radius) * tileSize;
                        baseY = (((li / (gridW + 1)) | 0) - radius + 0.5) * tileSize;
                    } else {
                        const li = i - b3;
                        baseX = ((li % gridW) - radius + 0.5) * tileSize;
                        baseY = (((li / gridW) | 0) - radius + 0.5) * tileSize;
                    }
                    const rx = baseX * c45 - baseY * c45 + cx;
                    const ry = baseX * c45 + baseY * c45 + cy;
                    nodeTargets[px] = rx + (Math.random() - 0.5) * jit;
                    nodeTargets[py] = ry + (Math.random() - 0.5) * jit;
                }
            }
        }

        function stepColors() {
            [activeGrid, nextGrid] = [nextGrid, activeGrid];
            for (let i = 0; i < totalCells; i++) {
                const curC = nextGrid[i];
                if (Math.random() < mutationRate) {
                    let newC; do { newC = (Math.random() * numColors) | 0; } while (newC === curC);
                    activeGrid[i] = newC;
                    continue;
                }
                const nBase = i * 3;
                const c1 = nextGrid[neighborLUT[nBase]], c2 = nextGrid[neighborLUT[nBase + 1]];
                const n3 = neighborLUT[nBase + 2], c3 = n3 !== -1 ? nextGrid[n3] : curC;
                let b1s = 1e9, b1c = 0, b2s = 1e9, b2c = 0, b3s = 1e9, b3c = 0;
                for (let c = 0; c < numColors; c++) {
                    if (c === curC) continue;
                    const row = c * numColors;
                    let s = de2000[row + c1] + de2000[row + c2];
                    if (n3 !== -1) s += de2000[row + c3];
                    if (s < b1s) { b3s = b2s; b3c = b2c; b2s = b1s; b2c = b1c; b1s = s; b1c = c; }
                    else if (s < b2s) { b3s = b2s; b3c = b2c; b2s = s; b2c = c; }
                    else if (s < b3s) { b3s = s; b3c = c; }
                }
                const r = (Math.random() * 3) | 0;
                activeGrid[i] = r === 0 ? b1c : r === 1 ? b2c : b3c;
            }
        }

        function render() {
            if (!activeGrid || innerWidth !== w || innerHeight !== ht) initGrid();
            counts.fill(0);
            const nodes = this.cellNodes, pos = nodePositions;
            for (let i = 0; i < totalCells; i++) {
                const c = activeGrid[i], ptr = counts[c], buf = bufs[c], nBase = i * 3;
                const n0 = nodes[nBase] * 2, n1 = nodes[nBase + 1] * 2, n2 = nodes[nBase + 2] * 2;
                buf[ptr] = pos[n0]; buf[ptr + 1] = pos[n0 + 1];
                buf[ptr + 2] = pos[n1]; buf[ptr + 3] = pos[n1 + 1];
                buf[ptr + 4] = pos[n2]; buf[ptr + 5] = pos[n2 + 1];
                counts[c] = ptr + 6;
            }
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, w, ht);
            for (let c = 0; c < numColors; c++) {
                const count = counts[c];
                if (!count) continue;
                const buf = bufs[c];
                ctx.fillStyle = palette[c];
                ctx.beginPath();
                for (let i = 0; i < count; i += 6) {
                    ctx.moveTo(buf[i], buf[i + 1]);
                    ctx.lineTo(buf[i + 2], buf[i + 3]);
                    ctx.lineTo(buf[i + 4], buf[i + 5]);
                }
                ctx.fill();
            }
        }

        function loop(t) {
            if (paused) return;
            requestAnimationFrame(loop);
            driftNodes();
            if (t - lastColorTime > colorUpdateInterval) {
                stepColors();
                lastColorTime = t;
            }
            render();
        }
        
        const pause = () => paused = true;
        const resume = () => { if (!paused) return; paused = false; requestAnimationFrame(loop); };
        
        onmousedown = e => { if (!e.target.closest('.controls')) pause(); };
        onmouseup = resume;
        onmouseleave = resume;
        onkeydown = e => { if (e.code === 'Space') { e.preventDefault(); pause(); } };
        onkeyup = e => { if (e.code === 'Space') { e.preventDefault(); resume(); } };
        
        initGrid();
        requestAnimationFrame(loop);
    </script>
</body>
</html>