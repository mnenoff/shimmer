<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shimmer</title>
    <style>
        body,html{margin:0;padding:0;width:100%;height:100%;overflow:hidden;background:#222;cursor:pointer}
        canvas{display:block}
        #rarePauseToggle{position:absolute;bottom:10px;right:10px;width:15px;height:15px;opacity:.4;cursor:pointer;z-index:100}
        #rarePauseToggle:hover{opacity:1}
        #dimSlider{position:absolute;bottom:10px;left:10px;width:120px;height:20px;z-index:100;cursor:pointer;-webkit-appearance:none;background:rgba(255,255,255,.3);border-radius:10px}
        #dimSlider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;background:#fff;border-radius:50%}
        #dimSlider::-moz-range-thumb{width:24px;height:24px;background:#fff;border-radius:50%;border:none}
        #mutationSlider{position:absolute;bottom:40px;left:10px;width:120px;height:20px;z-index:100;cursor:pointer;-webkit-appearance:none;background:rgba(255,100,100,.3);border-radius:10px}
        #mutationSlider::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;background:#f66;border-radius:50%}
        #mutationSlider::-moz-range-thumb{width:24px;height:24px;background:#f66;border-radius:50%;border:none}
        #dimOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;opacity:.5;pointer-events:none;z-index:9999}
    </style>
</head>
<body>
    <input type="checkbox" id="rarePauseToggle" checked>
    <input type="range" id="dimSlider" min="0" max="99" value="50">
    <input type="range" id="mutationSlider" min="0" max="100" value="18" title="Mutation rate">
    <div id="dimOverlay"></div>
    <canvas id="canvas"></canvas>
    <script>
        const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
        const palette = ['#000000', '#FFFFFF', '#00FF00', '#FF00FF','#FFFF00', '#0000FF', '#FF0000', '#00FFFF','#FF8000', '#007FFF', '#80FF00', '#7F00FF','#008080', '#FF7F7F'];
        const numColors = 14;
        const tileSize = 30;
        
        const targetFPS = 10;
        const frameInterval = 1000 / targetFPS;
        let lastFrameTime = 0;
        
        function hexToRgb(hex){
            const v=parseInt(hex.slice(1),16);
            return[(v>>16)&255,(v>>8)&255,v&255];
        }
        function rgbToLab(rgb){
            let r=rgb[0]/255,g=rgb[1]/255,b=rgb[2]/255;
            r=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92;
            g=g>.04045?Math.pow((g+.055)/1.055,2.4):g/12.92;
            b=b>.04045?Math.pow((b+.055)/1.055,2.4):b/12.92;
            let x=(r*.4124564+g*.3575761+b*.1804375)/.95047;
            let y=r*.2126729+g*.7151522+b*.0721750;
            let z=(r*.0193339+g*.1191920+b*.9503041)/1.08883;
            x=x>.008856?Math.pow(x,1/3):7.787*x+16/116;
            y=y>.008856?Math.pow(y,1/3):7.787*y+16/116;
            z=z>.008856?Math.pow(z,1/3):7.787*z+16/116;
            return[116*y-16,500*(x-y),200*(y-z)];
        }
        function deltaE2000(lab1,lab2){
            const L1=lab1[0],a1=lab1[1],b1=lab1[2],L2=lab2[0],a2=lab2[1],b2=lab2[2];
            const C1=Math.sqrt(a1*a1+b1*b1),C2=Math.sqrt(a2*a2+b2*b2),Cb=(C1+C2)/2;
            const G=.5*(1-Math.sqrt(Math.pow(Cb,7)/(Math.pow(Cb,7)+Math.pow(25,7))));
            const a1p=(1+G)*a1,a2p=(1+G)*a2,C1p=Math.sqrt(a1p*a1p+b1*b1),C2p=Math.sqrt(a2p*a2p+b2*b2);
            let h1p=Math.atan2(b1,a1p)*180/Math.PI;if(h1p<0)h1p+=360;
            let h2p=Math.atan2(b2,a2p)*180/Math.PI;if(h2p<0)h2p+=360;
            const dLp=L2-L1,dCp=C2p-C1p;
            let dhp=0; if(C1p*C2p!==0){dhp=h2p-h1p;if(dhp>180)dhp-=360;else if(dhp<-180)dhp+=360}
            const dHp=2*Math.sqrt(C1p*C2p)*Math.sin(dhp*Math.PI/360),Lbp=(L1+L2)/2,Cbp=(C1p+C2p)/2;
            let hbp=h1p+h2p; if(C1p*C2p!==0){hbp=(h1p+h2p)/2;if(Math.abs(h1p-h2p)>180){if(h1p+h2p<360)hbp+=180;else hbp-=180}}
            const T=1-.17*Math.cos((hbp-30)*Math.PI/180)+.24*Math.cos(2*hbp*Math.PI/180)+.32*Math.cos((3*hbp+6)*Math.PI/180)-.2*Math.cos((4*hbp-63)*Math.PI/180);
            const dTheta=30*Math.exp(-Math.pow((hbp-275)/25,2)),Rc=2*Math.sqrt(Math.pow(Cbp,7)/(Math.pow(Cbp,7)+Math.pow(25,7)));
            const Sl=1+.015*Math.pow(Lbp-50,2)/Math.sqrt(20+Math.pow(Lbp-50,2)),Sc=1+.045*Cbp,Sh=1+.015*Cbp*T;
            const Rt=-Math.sin(2*dTheta*Math.PI/180)*Rc;
            return Math.sqrt(Math.pow(dLp/Sl,2)+Math.pow(dCp/Sc,2)+Math.pow(dHp/Sh,2)+Rt*(dCp/Sc)*(dHp/Sh));
        }

        const labPalette = palette.map(c => rgbToLab(hexToRgb(c)));
        const de2000Flat = new Float32Array(numColors * numColors); 
        for(let i=0;i<numColors;i++){
            for(let j=0;j<numColors;j++){
                de2000Flat[i * numColors + j] = deltaE2000(labPalette[i], labPalette[j]);
            }
        }

        let w, ht, paused=false;
        let mutationRate = 0.18;
        
        const h = 15;
        const c45 = .7071067811865476;
        const s45 = .7071067811865476;
        const triOff = [-h,-h,0,-h,0,-h,h,-h,h,-h,h,0,h,0,h,h,h,h,0,h,0,h,-h,h,-h,h,-h,0,-h,0,-h,-h];
        const rOff = new Float32Array(32);
        for(let k=0;k<8;k++){
            const o=k<<2;
            rOff[o]=triOff[o]*c45-triOff[o+1]*s45;
            rOff[o+1]=triOff[o]*s45+triOff[o+1]*c45;
            rOff[o+2]=triOff[o+2]*c45-triOff[o+3]*s45;
            rOff[o+3]=triOff[o+2]*s45+triOff[o+3]*c45;
        }

        let gridA, gridB;
        let activeGrid, nextGrid;
        let neighborLUT;
        let vertexCache;
        let bufs = new Array(numColors);
        let counts = new Uint32Array(numColors);
        let totalCells = 0;

        const MAX_VERTS = 1200000; 
        for(let i=0;i<numColors;i++) bufs[i] = new Float32Array(MAX_VERTS);

        dimSlider.oninput=()=>dimOverlay.style.opacity=dimSlider.value/100;
        mutationSlider.oninput=()=>mutationRate=mutationSlider.value/100;

        function initGrid() {
            w = canvas.width = innerWidth;
            ht = canvas.height = innerHeight;
            const d = Math.sqrt(w * w + ht * ht);
            const r = ((d / tileSize) >> 1) + 2;
            const gridW = r << 1;
            const gridH = r << 1;
            
            totalCells = gridW * gridH * 8;
            
            gridA = new Uint8Array(totalCells);
            gridB = new Uint8Array(totalCells);
            activeGrid = gridA;
            nextGrid = gridB;
            
            neighborLUT = new Int32Array(totalCells * 3); 
            vertexCache = new Float32Array(totalCells * 6);

            const cx = w >> 1, cy = ht >> 1;
            const getIdx = (tx, ty, tri) => (ty * gridW + tx) * 8 + tri;
            const dx = [0,-1,-1,-1,0,1,1,1];
            const dy = [-1,-1,0,1,1,1,0,-1];

            for (let ty = 0; ty < gridH; ty++) {
                const y = ty - r;
                const tpy = (y + .5) * tileSize;
                const tyc = tpy * c45;
                const tys = tpy * s45;

                for (let tx = 0; tx < gridW; tx++) {
                    const x = tx - r;
                    const tpx = (x + .5) * tileSize;
                    const rcx = tpx * c45 - tys + cx;
                    const rcy = tpx * s45 + tyc + cy;

                    for (let tri = 0; tri < 8; tri++) {
                        const idx = getIdx(tx, ty, tri);
                        
                        activeGrid[idx] = (Math.random() * numColors) | 0;

                        const o = tri << 2;
                        const vIdx = idx * 6;
                        vertexCache[vIdx]   = rcx;
                        vertexCache[vIdx+1] = rcy;
                        vertexCache[vIdx+2] = rcx + rOff[o];
                        vertexCache[vIdx+3] = rcy + rOff[o+1];
                        vertexCache[vIdx+4] = rcx + rOff[o+2];
                        vertexCache[vIdx+5] = rcy + rOff[o+3];

                        const nBase = idx * 3;
                        neighborLUT[nBase] = getIdx(tx, ty, (tri + 1) & 7);
                        neighborLUT[nBase+1] = getIdx(tx, ty, (tri + 7) & 7);

                        const ntx = tx + dx[tri];
                        const nty = ty + dy[tri];
                        
                        if (ntx >= 0 && ntx < gridW && nty >= 0 && nty < gridH) {
                            neighborLUT[nBase+2] = getIdx(ntx, nty, (tri + 4) & 7);
                        } else {
                            neighborLUT[nBase+2] = -1;
                        }
                    }
                }
            }
        }

        function step() {
            let tmp = activeGrid; activeGrid = nextGrid; nextGrid = tmp;
            
            const len = totalCells;
            const src = nextGrid;
            const dst = activeGrid;
            const lut = neighborLUT;
            const de = de2000Flat;
            const rate = mutationRate;
            const nc = numColors;

            for (let i = 0; i < len; i++) {
                const curC = src[i];

                if (Math.random() < rate) {
                    let newC;
                    do { newC = (Math.random() * nc) | 0; } while (newC === curC);
                    dst[i] = newC;
                    continue;
                }

                const lutIdx = i * 3;
                const n1 = lut[lutIdx];
                const n2 = lut[lutIdx + 1];
                const n3 = lut[lutIdx + 2];

                const c_n1 = src[n1];
                const c_n2 = src[n2];
                const c_n3 = (n3 !== -1) ? src[n3] : curC;

                let b1_s = 99999, b1_c = -1;
                let b2_s = 99999, b2_c = -1;
                let b3_s = 99999, b3_c = -1;

                for (let c = 0; c < nc; c++) {
                    if (c === curC) continue;
                    
                    const row = c * nc;
                    let s = de[row + c_n1] + de[row + c_n2];
                    if (n3 !== -1) s += de[row + c_n3];
                    
                    if (s < b3_s) {
                        if (s < b2_s) {
                            if (s < b1_s) {
                                b3_s = b2_s; b3_c = b2_c;
                                b2_s = b1_s; b2_c = b1_c;
                                b1_s = s;    b1_c = c;
                            } else {
                                b3_s = b2_s; b3_c = b2_c;
                                b2_s = s;    b2_c = c;
                            }
                        } else {
                            b3_s = s;    b3_c = c;
                        }
                    }
                }

                let choices = 1;
                if (b2_c !== -1) choices = 2;
                if (b3_c !== -1) choices = 3;
                
                const r = (Math.random() * choices) | 0;
                if (r === 0) dst[i] = b1_c;
                else if (r === 1) dst[i] = b2_c;
                else dst[i] = b3_c;
            }
        }

        function draw() {
            if (!activeGrid || innerWidth !== w || innerHeight !== ht) initGrid();
            
            step();

            counts.fill(0);
            
            const ag = activeGrid;
            const vc = vertexCache;
            const len = totalCells;
            
            for (let i = 0; i < len; i++) {
                const c = ag[i];
                const ptr = counts[c];
                const vIdx = i * 6;
                const buf = bufs[c];
                
                buf[ptr]   = vc[vIdx];
                buf[ptr+1] = vc[vIdx+1];
                buf[ptr+2] = vc[vIdx+2];
                buf[ptr+3] = vc[vIdx+3];
                buf[ptr+4] = vc[vIdx+4];
                buf[ptr+5] = vc[vIdx+5];
                
                counts[c] = ptr + 6;
            }
            
            for (let c = 0; c < numColors; c++) {
                const count = counts[c];
                if (count === 0) continue;
                
                const buf = bufs[c];
                ctx.fillStyle = palette[c];
                ctx.beginPath();
                
                for (let i = 0; i < count; i += 6) {
                    ctx.moveTo(buf[i], buf[i+1]);
                    ctx.lineTo(buf[i+2], buf[i+3]);
                    ctx.lineTo(buf[i+4], buf[i+5]);
                }
                ctx.fill();
            }
        }

        function schedule(timestamp) {
            if (paused) return;
            
            requestAnimationFrame(schedule);
            
            const elapsed = timestamp - lastFrameTime;
            if (elapsed < frameInterval) return;
            
            lastFrameTime = timestamp - (elapsed % frameInterval);
            draw();
        }
        
        function pause(){if(paused)return;paused=true}
        function resume(){if(!paused)return;paused=false;requestAnimationFrame(schedule)}
        
        onmousedown=e=>{if(e.target!==rarePauseToggle&&e.target!==dimSlider&&e.target!==mutationSlider)pause()};
        onmouseup=resume;
        onmouseleave=resume;
        onkeydown=e=>{if(e.code==='Space'){e.preventDefault();pause()}};
        onkeyup=e=>{if(e.code==='Space'){e.preventDefault();resume()}};
        
        initGrid();
        requestAnimationFrame(schedule);
    </script>
</body>
</html>
